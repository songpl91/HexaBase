# 偏移坐标计算公式详解

## 1. 什么是偏移坐标？

偏移坐标就像是**把六边形网格强行塞进一个方形表格**里的坐标系统。

想象一下：
- 你有一张方格纸（就像Excel表格）
- 你想在上面画六边形网格
- 但是六边形是斜的，不能完美对齐方格
- 所以你需要"偏移"某些行或列来适应

## 2. 偏移坐标的输入参数

**是的，偏移坐标传入的就是xy坐标值！**

```csharp
// 偏移坐标的构造
OffsetCoordinateOddQ(int q, int r)  // q相当于x，r相当于y
```

- **q** = 列坐标（相当于x轴）
- **r** = 行坐标（相当于y轴）

## 3. 为什么需要"偏移"？

### 3.1 六边形的排列问题

```
正常的方格排列：
□ □ □ □
□ □ □ □
□ □ □ □

六边形的实际排列：
⬡ ⬡ ⬡ ⬡
 ⬡ ⬡ ⬡ ⬡    ← 这一行向右偏移了半个位置
⬡ ⬡ ⬡ ⬡
 ⬡ ⬡ ⬡ ⬡    ← 这一行又向右偏移了半个位置
```

### 3.2 奇数列偏移 vs 奇数行偏移

我们项目使用的是**奇数列偏移（Odd-Q）**：

```
列号： 0  1  2  3  4
      ⬡  ⬡  ⬡  ⬡  ⬡   ← r=0
       ⬡  ⬡  ⬡  ⬡     ← r=1 (奇数列向上偏移)
      ⬡  ⬡  ⬡  ⬡  ⬡   ← r=2
       ⬡  ⬡  ⬡  ⬡     ← r=3 (奇数列向上偏移)
```

## 4. 核心计算公式详解

### 4.1 偏移坐标转轴向坐标

```csharp
public AxialCoordinate ToAxial()
{
    int axialQ = q;                    // Q坐标保持不变
    int axialR = r - (q - (q & 1)) / 2; // R坐标需要调整
    return new AxialCoordinate(axialQ, axialR);
}
```

**公式分解：**

1. **`q & 1`** - 判断q是否为奇数
   - `q & 1 = 0` 表示偶数列
   - `q & 1 = 1` 表示奇数列

2. **`(q - (q & 1)) / 2`** - 计算偏移量
   - 偶数列：`(q - 0) / 2 = q / 2`
   - 奇数列：`(q - 1) / 2 = (q-1) / 2`

3. **`r - 偏移量`** - 得到真实的轴向R坐标

### 4.2 轴向坐标转偏移坐标

```csharp
public static OffsetCoordinateOddQ FromAxial(AxialCoordinate axial)
{
    int q = axial.q;                           // Q坐标保持不变
    int r = axial.r + (axial.q - (axial.q & 1)) / 2; // R坐标加上偏移
    return new OffsetCoordinateOddQ(q, r);
}
```

这是上面公式的**逆运算**。

## 5. 通俗易懂的解释方法

### 5.1 用楼层比喻

```
想象一栋奇怪的大楼：
- 偶数楼层（0,2,4...）的房间号正常排列
- 奇数楼层（1,3,5...）的房间号都向上偏移了半层

你要找301房间：
- 如果用"大楼坐标"，它在3楼1号
- 如果用"真实坐标"，需要减去偏移量
```

### 5.2 用表格比喻

```
Excel表格中：
- A列、C列、E列（偶数列）：正常排列
- B列、D列、F列（奇数列）：每个格子都向上偏移半格

当你说"B3格子"时，实际位置可能在"真实的2.5行"
```

## 6. 实际计算示例

### 示例1：偶数列
```
偏移坐标：(2, 3)  // 第2列，第3行
计算过程：
- q = 2 (偶数列)
- q & 1 = 0
- 偏移量 = (2 - 0) / 2 = 1
- 轴向R = 3 - 1 = 2
结果：轴向坐标(2, 2)
```

### 示例2：奇数列
```
偏移坐标：(3, 3)  // 第3列，第3行
计算过程：
- q = 3 (奇数列)
- q & 1 = 1
- 偏移量 = (3 - 1) / 2 = 1
- 轴向R = 3 - 1 = 2
结果：轴向坐标(3, 2)
```

## 7. 世界坐标转换公式

```csharp
public Vector3 ToWorldPosition(float hexSize = 1.0f)
{
    float hexHeight = Mathf.Sqrt(3.0f) * hexSize;
    
    // 调整R坐标，处理奇偶列偏移
    int adjustedR = r - q / 2;
    float x = 1.5f * hexSize * q;
    float y = hexHeight * (adjustedR + q / 2.0f);
    
    // 处理负数奇数列的特殊情况
    if (q < 0 && q % 2 != 0)
    {
        y += hexHeight;
    }
    
    return new Vector3(x, y, 0);
}
```

**公式解释：**

1. **X坐标**：`x = 1.5f * hexSize * q`
   - 每列之间的距离是六边形宽度的1.5倍
   - 这是因为六边形的重叠部分

2. **Y坐标**：`y = hexHeight * (adjustedR + q / 2.0f)`
   - `adjustedR = r - q / 2`：先调整R坐标
   - 再加上`q / 2.0f`：补偿奇偶列的偏移

3. **特殊处理**：负数奇数列需要额外偏移

## 8. 常见误解澄清

### 误解1："偏移坐标不是xy坐标"
**正确理解**：偏移坐标就是xy坐标，只是这个xy是在"偏移网格"中的位置。

### 误解2："公式太复杂"
**正确理解**：公式的核心就是处理奇偶列的半格偏移，本质很简单。

### 误解3："为什么不直接用世界坐标"
**正确理解**：偏移坐标让我们能用整数来表示六边形位置，便于存储和计算。

## 9. 教学建议

当向别人解释时，建议按这个顺序：

1. **先画图**：画出六边形网格和方格网格的对比
2. **举例子**：用具体的坐标值演示计算过程
3. **解释原理**：说明为什么需要偏移
4. **实际应用**：展示在游戏中如何使用

## 10. 总结

偏移坐标的核心思想：
- **输入**：方格网格中的xy坐标
- **处理**：考虑奇偶列的偏移
- **输出**：六边形网格中的真实位置

记住这个口诀：**"奇数列向上偏，偶数列不用管，计算时减偏移，世界坐标加回来"**